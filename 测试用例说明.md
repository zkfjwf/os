# 测试用例说明

本实验的所有测试样例均统一放置在 `kernel/start.c` 文件中的 `start()` 函数内，通过在内核启动阶段依次调用不同测试函数，对各实验模块的功能进行验证。

------

### 实验一：内核启动与基本输出测试

实验一主要验证最基本的内核启动流程以及串口输出功能，其测试用例如下：

```c
console_puts("Hello OS\n");
```

该测试用于确认：

- 内核成功启动并进入 C 代码执行阶段
- UART 串口输出功能工作正常

------

### 实验二：内核 printf 与清屏功能测试

实验二的测试集中在 `test_printf_basic()` 函数中，主要包含：

- 基本格式化输出测试（`%d`、`%x`、`%s`、`%c`、`%%`）
- 边界条件测试（如 `INT_MAX`、`INT_MIN`、空字符串、NULL 指针）

该测试用于验证内核态 `printf` 的正确性与健壮性。

------

### 实验三：页表与内存管理测试

实验三包含三个核心测试函数：

- `test_physical_memory()`
  - 验证物理页分配与释放（`alloc_page` / `free_page`）
  - 检查页对齐与数据写入正确性
- `test_pagetable()`
  - 验证页表创建与虚拟地址到物理地址的映射
  - 检查页表项权限位设置
- `test_virtual_memory()`
  - 验证启用分页前后系统行为
  - 确认内核代码、数据与设备访问在分页开启后仍然正常

------

### 实验四：中断处理与异常机制测试

实验四的测试主要包括：

- `test_timer_interrupt()`
  - 验证时钟中断是否能被正确触发
  - 检查中断计数、定时器重装以及中断频率
- `test_exception_handling()`
  - 测试非法指令异常
  - 测试页故障（缺页异常）
  - 验证异常处理流程是否能正确返回或终止

------

### 实验五：进程管理与调度测试

实验五包含以下测试用例：

- `test_process_creation()`
  - 验证进程创建与进程表管理
  - 检查进程数量限制与资源回收
- `test_scheduler()`
  - 验证调度器是否能够在多个进程间正确切换
  - 观察时间片轮转与调度公平性
- `test_synchronization()`
  - 测试基于 `sleep` / `wakeup` 的同步机制
  - 验证生产者-消费者模型是否能正确运行

------

### 扩展项目：优先级调度系统测试

扩展项目的测试同样放置在 `start()` 函数的末尾，通过创建多个内核线程进行验证。

测试方式为：

- 调用 `create_kthread()` 创建多个内核线程
- 通过修改 `create_kthread()` 的**第二个参数（优先级）**
- 构造不同优先级组合场景，观察调度行为与运行顺序

该方式可用于验证：

- 高优先级进程是否优先获得 CPU
- Aging 机制是否能够防止低优先级进程长期饥饿

------

### 测试运行方式说明

所有测试均通过以下流程在 QEMU 中运行：

```bash
make clean
make
make run
```

需要注意的是：

- **部分实验测试不能同时启用**
- 例如：虚拟内存管理实验与中断实验均会初始化内核页表
- 同时启用可能导致测试相互干扰或结果不正确

因此，在实际测试时，应根据实验内容**按需启用对应测试代码**。